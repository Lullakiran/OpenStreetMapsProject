<html>
<head>
	<!-- Latest compiled and minified CSS -->
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">

	 
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap-theme.min.css">
	<link rel="stylesheet" href="http://cdn.jsdelivr.net/highlight.js/8.6/styles/xcode.min.css">
	<script src="http://cdn.jsdelivr.net/highlight.js/8.6/highlight.min.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>

</head>
<body>


<div class="container">
	<div class='row'>
		<div class="col-md-12">
			<h1>  OpenStreetMap - Data Wrangling with MongoDB </h1>
			<h4>  	Sinan Hanay </h4> 
			<hr/>
			 <h2 align="center"> I. Gathering Statistics</h3> 
			 			<p>  I cleaned the data for Ankara/Turkey. First I gathered the statistics, using xml tree parser.  </p>

		 </div>


		<div class="col-md-8">
 
 <pre><code class="python">def count_tags(root, tag):
    tag_count = 0 
    for i in root.findall(tag):
        tag_count += 1
    return tag_count

counts = {}
for i in ['node', 'way', 'relation' ]:
    counts[i] = count_tags(root, i)
counts['user'] = count_users(root)
print counts 
#{'node': 638467, 'relation': 220, 'user': 500, 'way': 92056} </code></pre>
<pre> Mongodb queries on json file confirms these numbers too <code class="python"> 
> db.ankara.distinct("created.user").length
500
> db.ankara.find({"type":"node"}).count()
638467
> db.ankara.find({"type":"way"}).count()
92056 
> db.ankara.find().count()
730523 </code></pre>
 </div>
	 	<div class="panel-primary col-md-4">
			  <div class="panel-heading"> Data Summary</div>
		 		

			    		<table class="table table-striped">
			    			<tr> <td> City </td><td> Ankara / Turkey </td> </tr>
	     					<tr> <td> # Node </td><td>638467 </td> </tr>
	     					<tr> <td> # Way </td><td> 92056 </td> </tr>
	     					<tr> <td> # Unique User </td><td> 500 </td> </tr>
	     					<tr> <td> # Relation </td><td> 220 </td> </tr>
	     					<tr> <td> # Documents</td><td> 730523 </td> </tr>
	     					<tr> <td> File Size (osm)</td><td>  134,784,285 bytes</td> </tr>
	     					<tr> <td> File Size (json)</td><td> 169,398,230 bytes </td> </tr>
	     					<tr> <td> Data Source </td><td> <a href="https://s3.amazonaws.com/metro-extracts.mapzen.com/ankara_turkey.osm.bz2"> mapzen.com </a></td> </tr>
	     					<tr> <td> Source File </td><td> project.py </a></td> </tr>

	     					
						</table>

			  
 
		</div>
</div>

<hr/>
	<div class='row'>
		<div class="col-md-12">
	<h2 align="center"> II. Data Cleaning </h2>
		<p>  The following problems have been spotted: </p>
	 	
			<dl class="dl-horizontal">
			  <dt> Capitalization</dt>
			  <dd> Places lack capitalization <i>(e.g. 'cad.' , u'kalekap\u0131s\u0131' , 'ANKARA')</i></dd>
			  <dt> Postcodes</dt>
			  <dd> All post codes should consist of exactly 5 digits, and should start with 06.</dd>
			  <dt> Abbreviations</dt>
			  <dd> Some place names are shortened <i>(e.g. 'Cad.', 'Cd', 'Sk.' for 'Caddesi'  and 'Sokak') </i>	</dd>
			</dl> 
		 


<br/> 
<h3> Capitalizations </h3>
str.title() function solves the capitalization problem. 
If the address fields has some abbreviations, first abbreviations are extended, then title() function ensures that 
the address names are properly capitalized. 

<pre><code>   node.setdefault('address',{}).update({ field: capitalize_turkish_title(extend_abbreviations(v))    }) 
</pre></code>
<br/>
However, since some words (i.e. connectors like 'and', 'or') should not be capitalized, I had to write a custom function like below (line 92 in project.py):

<pre><code>def capitalize_turkish_title(address):
    capitalized_address = ''
    connectors = ['ve', 'de', 'ile', 'ki', 'ya', 'ya da'] #these words should not be capitalized

    for word in address.split():
        capitalized_address += word + ' ' if word in connectors else word.title()+' '

    #if address.islower():
    #    print 'before capitalization: ', address, '\t after capitalization: ', capitalized_address
        
    return capitalized_address[:-1]  #discard the last character, whitespace</pre></code>
    <br/>
And some excerpt from the above function:
<pre><code class='html'>...........
before capitalization:  a city a.v.m 		 after capitalization:  A City A.V.M 
before capitalization:  ankara 	 		 after capitalization:  Ankara 
before capitalization:  kalekapısı sk no:16 	 after capitalization:  Kalekapısı Sk No:16 
...........
</pre></code>
<br/>
Checking the above records in MongoDB, gives
<pre><code> > db.ankara.find({"address.housename":/City/},{"address":1} )
{ "_id" : ObjectId("557efc7874e833154ff25aca"), "address" : { "city" : "Ankara", "street" : "İstanbul Yolu", "housename" : "A City A.V.M" } }

> db.ankara.find({"address.street":/Kalek/}, {address:1})
{ "_id" : ObjectId("557efc7b74e833154ff393cf"), "address" : { "city" : "Kale", "street" : "Kalekapısı Sk No:16" } }

> db.ankara.find({"address.city":/Ankara/}).count()
165
> db.ankara.find({"address.city":/ankara/}).count()
0 </pre></code>
which means that the words in address were correctly capitalized.
Note that I did not capitalize the place names, as some place use lowercase letters for their title.


<br/> <br/>
<h3> Postcodes </h3>
<br/>
Function correct_postcode is responsible for correcting postcodes (line 83 in <mark> project.py </mark>), which is given below:

<pre><code>def correct_postcode(postcode):  #postcodes must start with 06, and must be 5 digits long
    if len(postcode) != 5: # found short postcodes like 0600, 65 in the data
        #print 'postcode length is wrong', postcode
        return None
    elif re.match(r'(06\d\d\d)',postcode)  == None: #check if all digits (i.e. not Esma 3 Sokak) and starts with 06
        #print 'invalid postcode', postcode
        return None
    return postcode
    
</pre></code>
<br/>
An excerpt from this code for invalid postcodes are given.
<pre><code>postcode length is wrong 65
postcode length is wrong 0600
postcode length is wrong 0600
postcode length is wrong 0600
postcode length is wrong Kerkük Sokak
</pre></code>
<br/>
Next, I would like to check if all postcodes are in the range (06000,06999). However I noticed that postcodes were saved as a string field in MongoDB.
After converting postcode field to integers, I checked the range of postcodes. All the postcodes fall between the expected range.
<pre><code> > typeof db.ankara.findOne({"address":{"$exists":1}}).address.postcode
string
#the following line is from http://stackoverflow.com/questions/4973095/mongodb-how-to-change-the-type-of-a-field
> db.ankara.find({"address.postcode" : {$exists : true}}).forEach( 
function(obj) { obj.address.postcode = new NumberInt( obj.address.postcode ); 
db.ankara.save(obj); } );
> typeof db.ankara.findOne({"address":{"$exists":1}}).address.postcode
number
> db.ankara.find({ "$and": [ { "address.postcode" : { "$gte":06000} },     { "address.postcode" : { "$lte":06999} }  ]}).count()
235
> db.ankara.find({ "$or": [ { "address.postcode" : { "$lt":06000} },     { "address.postcode" : { "$gt":06999} }  ]}).count()
0 </pre></code>
As the code shows all the postcodes in the database are in the range of (6000,6999).

<br/><br/>


<h3> abbreviations</h3>
To extend abbreviations, I used the extend_abbreviations function (line 48 in <mark> project.py </mark>) : 
<pre><code class="python">def extend_abbreviations(address):
    extended_address = ''
    abbreviations = { 'Cd.': 'Caddesi', 'Cad.':'Caddesi', 'Cd':'Caddesi', 'Sk.':'Sokak', 
                    'Mah.':'Mahallesi', 'Blv.':u'Bulvar\u0131', 'Bul.':u'Bulvar\u0131'}
    for word in address.split():
        try:
            extended_address += abbreviations[word] + ' ' #check whether this word is an abbreviation 
            # print "before cleaning: ", address, "\t after cleaning: ", extended_address
        except:
            extended_address += word+ ' '
    
    return extended_address[:-1] #discard the last character, whitespace</pre></code>
<br/>
and an output excerpt from this function (by commenting out the line with the print statement)
<pre><code class="html">before cleaning:  Atatürk Blv. 	 	 after cleaning:  Atatürk Bulvarı
before cleaning:  Vekaletler Cad. 	 after cleaning:  Vekaletler Caddesi
before cleaning:  Tunalı Hilmi Cad. 	 after cleaning:  Tunalı Hilmi Caddesi
before cleaning:  Levent Sk. 	 	 after cleaning:  Levent Sokak
.............................................................
</pre></code>
<br/>
In addition, I also checked the database to see, if the values are cleaned as planned.
<pre> <code>
> db.ankara.find({"address.street":/Bulvar/},{"address":1} ).count()
23
> db.ankara.find({"address.street":/Blv./},{"address":1} ).count()
0

> db.ankara.find({"address.street":/Mah\./},{"address.street":1} ).count()
0

> db.ankara.find({"address.street":/Cad/},{"address":1} ).count()
149
> db.ankara.find({"address.street":/Cad\./},{"address":1} ).count()
1
> db.ankara.find({"address.street":/Cad\./},{"address":1} )
{ "_id" : ObjectId("557efc8274e833154ff56373"), "address" : { "street" : "Hipodrom Cad.;Talat Paşa Bulvarı", "housenumber" : "5" } }

> db.ankara.find({"address.street":/Sk\./},{"address.street":1} )
{ "_id" : ObjectId("557efc8374e833154ff59c4f"), "address" : { "street" : "2108.Sk." } }
{ "_id" : ObjectId("557efc7674e833154ff15281"), "address" : { "street" : "410.Sk." } }
{ "_id" : ObjectId("557efc7b74e833154ff3ac34"), "address" : { "street" : "2108.Sk." } }

</pre></code>
<br/>
Even though all entries for "Blv." have been successfully cleaned, there are small problems with "Cad.",  and "Sok.". Upon inspection, it is clear that 
the punctuations such as '.' and ';' just before or after these identifiers prevents the extend abbreviations to work correctly. Thus, I had to modify extend_abbreviations 
functions to not only split by 'space' but also by 'dot', 'comma' and 'semi-colon'.

to fix that I modified the function as below:
<pre> <code>def extend_abbreviations_split_by_multiple(address):
    extended_address = ''
    abbreviations = { 'Cd.': 'Caddesi', 'Cad.':'Caddesi', 'Cd':'Caddesi', 'Sk.':'Sokak', 
                    'Mah.':'Mahallesi', 'Blv.':u'Bulvar\u0131', 'Bul.':u'Bulvar\u0131'}
    splitted_address = re.findall(r'[^,;\s]+', address)
    for word in splitted_address:
        
        try:
            extended_address += abbreviations[word] + ' ' #check whether this word is an abbreviation 
            # print "before cleaning: ", address, "\t after cleaning: ", extended_address
        except:
            extended_address += word+ ' '
    return extended_address[:-1] #discard the last character, whitespace
</pre></code>
<br/>	
and it fixed the problems as shown below.

<pre> <code>> db.ankara.find({"address.street":/Cad\./},{"address":1} ).count()
0
> db.ankara.find({"address.street":/Cadde/},{"address.street":1} ).count()
150

> db.ankara.find({"address.street":/Sk\./},{"address.street":1} )
> db.ankara.find({"address.street":/Sk\./},{"address.street":1} ).count()
0
> db.ankara.find({"address.street":/Sokak/},{"address.street":1} ).count()
153 </pre></code>





<br/><br/><br/>
<h2 align="center"> III. Data Analysis </h2>
			<h3>Post Codes </h3>
			First I looked at the most commong postcodes.
			<pre><code> #checking for most common postcodes
> db.ankara.aggregate({"$match":{"address.postcode":{"$exists":1}}} , 
{"$group": {"_id":"$address.postcode", "count":{"$sum":1}}}, 
{"$sort":{"count":-1}} )

{ "_id" : "06800", "count" : 149 }
{ "_id" : "06810", "count" : 14 }
{ "_id" : "06900", "count" : 11 }
{ "_id" : "06700", "count" : 6 }
{ "_id" : "06540", "count" : 5 }
{ "_id" : "06550", "count" : 5 }</pre></code>
<p> I noticed that 06800 is the dominating postcode, and it belongs to <mark>University District</mark>, which contains two important universities: <mark>Bilkent</mark> and <mark>Middle East Technical University</mark>. 
This area is far from the city center, and not necessarily the densest district. This data probably suggests that university students/staff has been more inclined to enter data. </p>
<br/>





<h3>Most Active Users </h3> Next I looked at who were the most active users.
<pre><code> > db.ankara.aggregate({"$group" :{"_id":"$created.user", "count":{"$sum":1}}}, 
{"$sort":{"count":-1}})
{ "_id" : "penom", "count" : 190775 }
{ "_id" : "katpatuka", "count" : 136518 }
{ "_id" : "summerson", "count" : 128541 }
{ "_id" : "VinothS", "count" : 28441 }
{ "_id" : "nesim", "count" : 19158 }
{ "_id" : "vignesh anand", "count" : 14187 }
{ "_id" : "SathyaV", "count" : 14114 }</pre></code>
  From these usernames only Nesim is a Turkish name. Vinoth, Vignesh, Summerson and Sathya are definetely not Turkish. Penom and katpatuka maybe nicknames, or non-Turkish names.
 This may suggest that Turkish people are reluctant to enter data. I will elaborate this point in the conclusion.

<br/><br/>
<h3>Ways with Highest Number of Nodes </h3>
Next I looked at the place types that has the most nodes. 
<pre><code> > heavy_roads = db.ankara.aggregate( {"$unwind" : "$node_refs"} , 
		 { "$group" : {"_id" : "$_id", "node_ref_count": { "$sum" :1}}}, 
		 { "$sort" : {"node_ref_count":-1}}, {"$limit":4}) 

{ "_id" : ObjectId("5579c58e3ed2011936d9325c"), "node_ref_count" : 465 }
{ "_id" : ObjectId("5579c58e3ed2011936d9325d"), "node_ref_count" : 465 }
{ "_id" : ObjectId("5579c58c3ed2011936d8a385"), "node_ref_count" : 326 }
{ "_id" : ObjectId("5579c58e3ed2011936d965f7"), "node_ref_count" : 316 }

> db.ankara.find({ "_id" : ObjectId("5579c58e3ed2011936d9325c")},{"node_refs":0, "_id":0,"created":0, "visible":0, "type":0, "id":0})
{ "leisure" : "park" }

> db.ankara.find({ "_id" : ObjectId("5579c58e3ed2011936d9325d")},{"node_refs":0, "_id":0,"created":0, "visible":0, "type":0, "id":0})
 { "barrier" : "hedge" }

> db.ankara.find({ "_id" : ObjectId("5579c58c3ed2011936d8a385")},{"node_refs":0, "_id":0,"created":0, "visible":0, "type":0, "id":0})
{ "highway" : "service" }

> db.ankara.find({ "_id" : ObjectId("5579c58e3ed2011936d965f7")},{"node_refs":0, "_id":0,"created":0, "visible":0, "type":0, "id":0})
{ "waterway" : "stream" }
</pre></code>
I tried to look at the places from coordinates, the first one is a sports complex, and the highway and stream makes sense to be there.

<br/><br/>
<h3>The Most Common Amenities</h3>
The most common amenities, I think parking is surprising. I would not have expected so many parking places in Ankara. Though, that is probably because 
the mapped dataset is small portion of the whole city.
<pre><code> > db.ankara.aggregate({"$match":{"amenity":{"$exists":1}}}, {"$group":{"_id":"$amenity", "count":{"$sum":1}}}, 
			{"$sort":{"count":-1}}, {"$limit":5})
{ "_id" : "place_of_worship", "count" : 823 }
{ "_id" : "parking", "count" : 512 }
{ "_id" : "school", "count" : 289 }
{ "_id" : "restaurant", "count" : 219 }
{ "_id" : "fuel", "count" : 210 }
</pre></code>
<br/>
<h3>The Most Popular Streets</h3>
This is the most surprising result, as I never heard any of the following. I also checked Internet and looks like they are not significant.
In the conclusion section, I explain why such a situation happens.
<pre><code> > db.ankara.aggregate({"$match":{"address.street":{"$exists":1}}}, {"$group": {"_id":"$address.street", "count" : {"$sum":1}}}, 
			{"$sort":{"count":-1}}, {"$limit":5} )
{ "_id" : "Tutumlu Sokak", "count" : 18 }
{ "_id" : "İbni Sina Caddesi", "count" : 16 }
{ "_id" : "Ulubey Sokak", "count" : 15 }
{ "_id" : "Yavuzevler Sokak", "count" : 15 }
{ "_id" : "1598. Caddesi", "count" : 11 }
</pre></code>
<br/>
<h3>Common Names in Restaurants and Schools</h3>
I always thought restaurant names in Turkey are somewhat similar. A search in the database showed 3 restaurants have the same name Aspava, which is a very common restaurant name
in any city. Then I searched the database for the restaurant names that includes Aspava, and there are 8 restaurants having Aspava in their names (e.g. Aspava Park, Koç Aspava, Yıldız Aspava etc.)
<pre><code> > db.ankara.aggregate( {$match : {"amenity":"restaurant"}} , {$group: { "_id":"$name" , "count":{$sum:1}}}, {$sort: {"count":-1}} )
{ "_id" : null, "count" : 11 }
{ "_id" : "Aspava", "count" : 3 }
{ "_id" : "Uludağ", "count" : 2 }
{ "_id" : "Aslı Börek", "count" : 2 }
{ "_id" : "Çorbacım", "count" : 2 }

> db.ankara.aggregate(  {$match: { $text : { $search:"aspava"}}}, {$group: {"_id": "$amenity" , "count": {$sum:1}}} )
{ "_id" : "restaurant", "count" : 8 }      
</pre></code>
<br/>
Similar to Aspava, Anadolu is a very common name in school names, especially in high schools names. Because Anadolu high schools are somewhat premiere schools. 33 out of 94 high schools, 
has 
<pre><code> > db.ankara.find({ name:/Lise/}).count()
94
> db.ankara.aggregate(  {$match: { $text : { $search:"Anadolu"} , "amenity":"school"  }}, {$group: {"_id": "$amenity" , "count": {$sum:1}}}  )
{ "_id" : "school", "count" : 33 }
</pre></code>
		</div>
	</div>

 


<div class='row'>
		<div class="col-md-12"><br/>
	<h2 align="center"> IV. Other Ideas </h2>


	<h3>Problems</h3>

	When I looked at this data, one thing about street names surprised me.  
	I would like to present briefly some background information before explaining what surprised me.
	Different countries have different addressing schemes.
	  
    I just looked up top restaurants from Yelp ( I removed district names from both)
     
    <ul> 
    	<li>	1723 N Halsted St., Chicago </li> 
    	<li>   Istiklal Street. Emir Nevruz Road. 2/E, Beyoglu (district),  Istanbul</li> 
    	<li>   Jingumae 4-15-3, Shibuya(district), Tokyo </li>
    </ul>

		<p>For example, in USA, it is succinct to describe an address by street (N Halsted) and number (1723).
		In Turkey, there are streets and roads. Streets are long  and well known, roads are short and unremarkable. 
		Thus, the address of a point is described by both street and road names most of the time. Because describing 
		just by either one of them will have make them harder to find.</p>

		<p>Thus, in data I was expecting in street field to have both road and street, but only a few entries have it.
		I guess it is either because mostly foreigners entered it, or people who entered could not decide what to do.
		As a result, in the "Most Popular Streets" query, top results are some small, insignificant roads. 
		For example, I would surprise if somebody just uses Tutumlu Road and Ulubey Road alone, but both are just next to well known Baglar Street.
		Thus, it would be probably more accurate if also the closest street  name were included (i.e. Baglar Street, Ulubey Road).
		I heard that after foursquare started using OpenStreetMap, people started to complain about the new map, and I can understand why now.</p>

		<p> The situation gets more interesting for Japan, where there are no streets. The address given tells that in Jingumae-4 region, look for block id 15 and building number 3.
		So for Japan, how should be the street fields populated? Because 4-15-3 and 4-15-4 can be on same street, but 4-15-5 can be on another street.</p>


 <br/>
 <h3>Improvement</h3>	
	
	  <div class="col-lg-8 pull-left"> 
	 			
	   The reason for discrepancies is variety in city plans. An optimized addressing city scheme depends on the city plan itself. In a grid-like American city, it is better to
		use street and number system. On the other hand, in Turkey each street have lots of connecting roads. In Japan, there are roads as short as tens of meters. </p>


	   <p> 	I propose a solution to this problem using grid based mapping, which is similar to Japanese addressing system. In the image right, New York City map is shown 
	   (map source:<a href="https://www.etsy.com/listing/119087221/1944-new-york-city-manhattan-grid-map">etsy.com</a>). A coarse griding is illustrated for the sake of simplicity, where
	   each point corresponds to a square of roughly 1 km by 1 km.</p>

	  <p>  With this system places can give their address very briefly,
	   such as New York Stack Exchange would be N5 or maybe N5 South. Basically a database that maps geo-coordinates to regions that can be described by a letter and a digit. 
	   For New York, this might be unnecessary since it is addressing is very regular, but for other metropolitans that can be helpful for places to describe their addresses briefly.
	   As a result, data entering will be much more consistent, and faster. 
	</p>
 
 		<p>
 			Unlike New York, many cities in the world have irregularly named street names. As a result, I do not see a reason to use real street names. Also many people already have GPS capable smartphones. We should enter an address like "A23 Tokyo", and it should point a region that is, say 100 meters by 100 meters.
 				   Twenty years ago, people used to memorize phone numbers of friends, or carry phonebooks. Nowadays,   some people even do not know their own phone number. 
 		</p>

	     </div>

	      <div class="col-lg-4"> <img src="etc/drawing.jpg" class="img-rounded pull-left img-responsive"/>   </div>


</div>
</div>




 


</body>
</html>